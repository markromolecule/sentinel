-- =========================
-- ENUMS
-- =========================
CREATE TYPE public.user_status AS ENUM ('ACTIVE', 'INACTIVE');

-- =========================
-- ROLES & RBAC
-- =========================
CREATE TABLE public.roles (
  role_id SMALLINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  role_name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE public.user_roles (
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  role_id SMALLINT REFERENCES public.roles(role_id) ON DELETE CASCADE,
  PRIMARY KEY (user_id, role_id)
);

ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- =========================
-- USER PROFILE (EXTENSION OF auth.users)
-- =========================
CREATE TABLE public.user_profiles (
  user_id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  first_name VARCHAR(100),
  last_name VARCHAR(100),
  avatar_url TEXT,
  status user_status DEFAULT 'ACTIVE',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;

-- Create a simplified policy to allow users to read their own profile
CREATE POLICY "Users can view own profile" 
ON public.user_profiles FOR SELECT 
USING (auth.uid() = user_id);

-- Create a policy for users to update their own profile
CREATE POLICY "Users can update own profile" 
ON public.user_profiles FOR UPDATE 
USING (auth.uid() = user_id);

-- =========================
-- TRIGGER: AUTO-CREATE PROFILE
-- =========================
-- This function is called by the trigger every time a new user is created in auth.users
CREATE OR REPLACE FUNCTION public.handle_new_user() 
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.user_profiles (user_id, first_name, last_name)
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'first_name',
    NEW.raw_user_meta_data->>'last_name'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- =========================
-- ACADEMIC STRUCTURE
-- =========================
CREATE TABLE public.departments (
  department_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  department_name VARCHAR(100) UNIQUE NOT NULL
);

ALTER TABLE public.departments ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.students (
  student_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  student_number VARCHAR(50) UNIQUE NOT NULL,
  department_id UUID REFERENCES public.departments(department_id)
);

ALTER TABLE public.students ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.subjects (
  subject_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  subject_code VARCHAR(50) UNIQUE NOT NULL,
  subject_title VARCHAR(255) NOT NULL,
  department_id UUID REFERENCES public.departments(department_id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE public.subjects ENABLE ROW LEVEL SECURITY;

CREATE TABLE public.sections (
  section_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  section_name VARCHAR(50) NOT NULL,
  year_level SMALLINT CHECK (year_level BETWEEN 1 AND 6),
  department_id UUID REFERENCES public.departments(department_id),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (section_name, year_level, department_id)
);

ALTER TABLE public.sections ENABLE ROW LEVEL SECURITY;

-- =========================
-- ACADEMIC TERMS
-- =========================
CREATE TABLE public.terms (
  term_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  academic_year VARCHAR(20) NOT NULL,
  semester VARCHAR(20) NOT NULL,
  is_active BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (academic_year, semester)
);

ALTER TABLE public.terms ENABLE ROW LEVEL SECURITY;

CREATE UNIQUE INDEX one_active_term
ON public.terms (is_active)
WHERE is_active = true;

-- =========================
-- CLASS GROUPS
-- =========================
CREATE TABLE public.class_groups (
  class_group_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  subject_id UUID REFERENCES public.subjects(subject_id) ON DELETE CASCADE,
  section_id UUID REFERENCES public.sections(section_id) ON DELETE CASCADE,
  term_id UUID REFERENCES public.terms(term_id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (subject_id, section_id, term_id)
);

ALTER TABLE public.class_groups ENABLE ROW LEVEL SECURITY;

-- =========================
-- CLASS-LEVEL ROLE ASSIGNMENT
-- =========================
CREATE TABLE public.class_roles (
  class_group_id UUID REFERENCES public.class_groups(class_group_id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  role_id SMALLINT REFERENCES public.roles(role_id),
  assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  PRIMARY KEY (class_group_id, user_id, role_id)
);

ALTER TABLE public.class_roles ENABLE ROW LEVEL SECURITY;

-- =========================
-- STUDENT ENROLLMENTS
-- =========================
CREATE TABLE public.enrollments (
  enrollment_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  class_group_id UUID REFERENCES public.class_groups(class_group_id) ON DELETE CASCADE,
  student_id UUID REFERENCES public.students(student_id) ON DELETE CASCADE,
  enrolled_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (class_group_id, student_id)
);

ALTER TABLE public.enrollments ENABLE ROW LEVEL SECURITY;

-- =========================
-- BASE RLS POLICIES (DEV MODE - RESTRICTIVE DEFAULT)
-- =========================
-- NOTE: You will need to add more specific policies for your app to function fully.
-- For now, we allow authenticated users to view basic academic data (departments, subjects, terms)
-- so the app doesn't crash on load.

CREATE POLICY "Authenticated users can view departments" ON public.departments FOR SELECT TO authenticated USING (true);
CREATE POLICY "Authenticated users can view subjects" ON public.subjects FOR SELECT TO authenticated USING (true);
CREATE POLICY "Authenticated users can view terms" ON public.terms FOR SELECT TO authenticated USING (true);
CREATE POLICY "Authenticated users can view sections" ON public.sections FOR SELECT TO authenticated USING (true);